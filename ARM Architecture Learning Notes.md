> 所谓嵌入式开发，就是去控制硬件，也就是驱动。

[TOC]

# 1. ARM基础

## 1.1. ARM公司

&emsp;&emsp;ARM公司前身为Acorn计算机公司，主要设计ARM系列RISC处理器内核，授权ARM内核给生产和销售半导体的合作伙伴(ARM公司不生产芯片)。

## 1.2. ARM产品线

&emsp;&emsp;ARM产品线分为三个系列：
> - Cortex-A系列：高端系列，用于手机这类产品；
> - Cortex-R系列：实时系列，多用于汽车电子等产品；
> - Cortex-M系列：低端系列，用于MCU，FPGA等；

## 1.3. 授权厂商

> - Samsung(三星)；
> - Qualcomm(高通)；
> - Nvidia(英伟达) - 显卡；
> - Freescale(飞思卡尔)(NXP恩智浦)；
> - TI(德州仪器)；
> - Marvell(马维尔) - 网卡；
> - ...

## 1.4. ARM体系架构

- 不同ARM体系采用不同指令集；
- 冯诺依曼(普林斯顿)结构指令和数据混合存储；
- 哈弗结构指令和数据分开存储；

|ARM体系结构|ARMv4|ARMv5|ARMv6|ARMv7|
|:---:|:---:|:---:|:---:|:---:|:---:|
|ARM CPU|arm7|arm9/arm10|arm11|Cortex-A8|
|流水线|3|5/6|8|NC|
|频率(MHz)|80|150/260|335|667|
|MMU|No/Yes|Yes|Yes|Yes|
|结构|冯氏|哈式|哈式|哈式|

## 1.5. ARM系统硬件组成

- CPU = ALU运算器 + 控制器(取指令) + 寄存器(临时存储)；
- FLASH(NOR,NAND)、eMMC、硬盘；
- 内存；

# 2. 搭建开发环境

- 1. 安装交叉编译工具链(针对不同平台安装)。
- 2. 安装keil(可以测试汇编和C语言)
- 3. 创建工程(在keil中创建工程，添加.s汇编文件名)
- 4. keil关联到交叉编译工具链 
  >  - 分级找到"Use GCC"选项；
  >  - Project
      - Manager
        - Components
          - Folders
            - 勾选Use GCC
  >  - 设置"GUN Tool Prefix"为安装的交叉编译工具链；
  >  - 设置"GUN Tool Folder"为交叉编译链安装目录；
- 5. 导入Linker脚本
  >  - 创建合适的.lds链接文件；
  >  - 分级设置：
  >  - Project
        - Options For Target
        - Linker
  >  - 设置Linker Script File为.lds文件；
- 6. 最后
  >  - 编译代码
  >  - 调试代码(调式模式下可以看到寄存器值)

# 3. ARM工作模式和寄存器

## 3.1. 7种工作模式

> - 用户(usr)：正常 ARM 程序执行状态；
> - 快中断(fiq)：为支持数据传输或通道处理设计；
> - 中断(irq)：用于一般用途的中断处理；
> - 管理(svc)：操作系统保护模式；
> - 中止(abt): 数据或指令预取中止后进入；
> - 系统(sys)：操作系统的特权用户模式；
> - 未定义(und)：执行了一个未定义指令时进入

## 3.2. 37个寄存器

> - 1个PC寄存器
> - 1个CPSR寄存器
> - 5个SPSR寄存器
> - 30个通用寄存器
>   - R0 - R15
>   - R0 - R14通用寄存器；
>   - R15：PC
>   - R14：LR
>   - R13：SP 
>   - R16：CPSR
> - 不同工作模式某些寄存器有多个用于备份，比如SP，切换工作模式的时候需要注意恢复之后才能使用原先寄存器中的值；

## 3.3. CPSR寄存器

> - 当前程序状态寄存器
> - `mrs r0 CPSR`：表示将CPSR的值赋值给r0；
> - `msr CPSR r0`：表示将r0的值赋值给CPSR；
> - 可以指示当前处于哪种工作模式；
> - 可以禁止和启用IRQ和FIQ；
> - 可以指定当前处于ARM状态还是Thumb状态；
> - 记录上一次ALU处理后的标志(负数,零,借位,溢出)
> - 等等

# 4. ARM指令

## 4.0. 机器码

- 接下来以`moveq r0,r1`来介绍机器码
  - `moveq r0,r1`的机器码是0x01A00001；
  - ARM指令集是32位的，Thumb指令集是16位的；
  - 以ARM指令为例，一条汇编指令对应的机器码是32位；
    -  0-11：Rs，源操作数；
    - 12-15：Rd，目的寄存器；
    - 16-19：0000，SBZ，
    -    20：0-无S标志，1-有S标志；
    - 21-24：opcode，操作码；
    -    25：1-立即数，0-寄存器
    - 26-27：00，
    - 28-31：cond，条件码(EQ,NE,LT,GT,LE,GE...)
- 操作码和条件码可以组合使用，依据CPSR的NZCV来判断是否执行；
- 由于机器码的限制，立即数最大为12位，可用**伪指令**使用操作12位的立即数(ldr r0,=0x12345678)(是"="不是"#")；

## 4.1. 搬移指令

- `mov r0,#6`：将立即数6赋值给r0寄存器；
- `mov r1,r0`：将寄存器r0的值赋值给寄存器r1；
- `mov r2,r0,LSL#2`：将r0的值逻辑左移两位之后赋值给r2；
- `mov r3,r0,LSR#2`：将r0的值逻辑右移两位之后赋值给r3；
- `mrs r4,cpsr`：将cpsr的值赋给r4；
- `msr cpsr,r5`：将r5的值赋给cpsr(如果是普通模式切换别的模式，指令执行完并不会切换，可使用`swi`软中断指令先制造中断，进入中断模式之后再切换到想要的模式)；

## 4.2. 条件判断

- 下面举例C语言的**条件判断**对应的汇编
  ```C
    if (0 == flg)
      var = 0;
    if (a > 0)
      var = var + 1;
  ```
  ```asm
    cmp r0,#0
    moveq r1,#0
    addgt r1,r1,#1
  ```
- `cmp`指令直接之后，CPSR寄存器种的Z位记录了是否相等，`moveq`指令是判断紧接着前面一条的比较指令，相等的时候做的操作，`addgt`是判断紧接着前面一条比较指令的结果是大于时的操作；

## 4.3. 逻辑指令

- `and r0,r1,#0xFF`<==>`r0 = r1 & 0xFF`，位与并赋值；
- `orr r0,r1,#0x0F`<==>`r0 = r1 | 0x0F`，位或并赋值；
- `bic r0,r0,#0x01`<==>`r0 = r0 & 0xFFFFFFFE`，清r0的位0位；
- `bic r0,r0,#~0x000000001`：清除了0的位，"~"取反操作；
- `tst r0,#0x01`<==>测试r0的位0位，如果为0置CPSR的Z位为1；

## 4.4. 算数指令

- `add r0,r1,#1`<==>`r0 = r1 + 1`
- `add r0,r1,r2,LSL#1`<==>`r0 = r1 + (r2 << 1)`
- `sub r0,r1,r2`<==>`r0 = r1 - r2`
- `mul r0,r1,r2`<==>`r0 = r1 * r2`
  
## 4.5. 跳转指令

- 跳转指令有：`b`、`bl`、`beq`、`bne`
- `b LABLE`：表示跳到标号LABLE处执行；
- `bl func`：先保存下一条指令的地址到LR寄存器，然后跳转到func函数执行，最后调用`mov pc,lr`跳回(也可用`b`实现，但是不方便)；
- `beq/bleq addr`：当CPSR中的Z位置位时跳转到该地址；
- `bne/blne addr`：当CPSR中的Z位未置位时跳转到该地址；

## 4.6. 存储器操作指令  

> &emsp;&emsp;ARM架构规定，存储器之间不能直接拷贝数据，需要通过寄存器中转。

- 读存储器指令：`ldrb`、`ldrh`、`ldr`
  - `ldrb`：从存储器读字节
  - `ldrh`：从存储器读半字
  - `ldr`：从存储器读字

  - `ldr r0,[r1]` ：r1存放存储器地址，从该地址读数据到r0；
  - `ldr pc,Label`：将标号Label中的内容放到PC中；
  - `ldr pc,=Label`：<font color=red>和上条指令的区别？</font>

- 写存储器指令：`strb`、`strh`、`str`
  - `str r0,[r1]`：将r0中的数据写到r1代表的存储器地址上；
  - `str r0,[r1,#4]`：前索引，将r0中的数据写到r1+4代表的存储器地址上，r1还是原地址；
  - `str r0,[r1,#4]!`：和上条指令不同的是r1(基址寄存器)会变为r1+4的值；
  - `str r0,[r1],#4`：后索引，将r0中的数据写到r1代表的存储器地址上，并且r1+4；

## 4.7. 批量操作指令

- 指令附加
  - ia：increment after
  - ib：increment before
  - da：decrement after
  - db：decrement before
- `ldmia r8!,{r0 - r7}`
  - "r8!"：中的"!"会使得r8自动加4；
  - "ldmia"：表示先取值再增加地址；
  - "{r0 - r7}"：8个寄存器，表示该指令**一次**会读取8个寄存器值
- `stmia r9!,{r0 - r7}`
  - 处理方式同"ldmia"，只不过这个指令是存储数据；

## 4.8. 堆栈操作指令

- `stmfd sp!,{r0-r6,lr}`
  - 入栈操作，多用于中断发生时保护现场；
  - "!"表示sp寄存器自动偏移；
  - 入栈会自动先压高索引的寄存器，这里先压lr,最后压r0；
- `ldmfd sp!,{r0-r6,pc}^`
  - 出栈操作，多用于恢复现场；
  - "!"表示sp寄存器自动偏移(sp存储的栈指针改变):
  - "^"表示恢复spsr的值到cpsr中；
  - 出栈顺序和入栈顺序相反，最后出lr；

## 4.9. 软中断指令

- "swi 0x01"
  - "swi"用于产生软中断，多用于在普通模式想切换到其他模式时使用(普通模式不能主动切换到别的模式)；
  - "0x01"：软中断号(比如系统调用中的每个函数对应不同的软中断号)；
  - "swi"指令调用时会做如下处理：
    - 会保存下一条指令的地址到LR寄存器；
    - 然后跳转到异常向量表，所以异常向量表中使用的是"b"而不是"bl"来执行中断处理函数；
    - 将模式切换到SVC模式；
- 怎么获取"swi"的软中断号来调用不同的系统调用：
  - swi指令执行时会保存下一条指令的的地址到lr中，通过"sub r0,lr,#4"对lr值减4获取当前swi指令的地址；
  - 然后对swi的机器码获取低24位就可以获取到软中断号了；

# 5. 伪指令

|伪指令|说明|
|:-:|:-|
|.text|定义一段代码段(可多次定义)的开始，只读|
|.data|定义一段数据段，可读可写 |
|.end|文件结束|
|.equ|定义宏(`.equ A B`用A代替B)|
|.byte|定义变量或数组元素的长度为一字节|
|.word|定义变量或数组元素的长度为4字节|
|.string|定义字符串(`.string "hello\0"`)|
|.space|指定数组的元素个数|
|ldr|加载源操作数大于12位的立即数到寄存器(`ldr r0,=0x12345678`)|
|.global|声明一个全局符号(`.global _stat`)|
|.section||

## 5.1. "ldr"伪指令和"ldr"指令

- 伪指令的使用格式是`ldr r0,=0x12345678`
- 指令的使用格式是`ldr r0,[r1]`
- 一个特殊的例子，中断向量表中使用的是指令，不是伪指令：
  ```ASM
    .text
    @中断向量表
    ldr pc,_swi_handler@间接将软中断处理函数地址赋值给PC，这里突破"b"指令能操作的空间限制

    _swi_handler:
      .word swi_handler@保存软中断处理函数的地址到该标号，.word表示存储4字节

    swi_handler:@软中断处理标号，函数地址
      @软中断处理函数体

    swi_handler_end:@软中断处理函数结束
      
  ```

  ```ASM
    .text
      @代码段    

    .data
      @数据段
  buf:
    .byte 0x01,0x02,0x03  @char buf[]={0x01,0x02,0x03}
  buf2:
    .space 6 @char buf[6];

    .end
  ```

# 6. 异常处理

## 6.1. 异常种类

|异常|描述|使用场景|
|:-:|:-|:-|
|中断|IRQ、FIQ|外部硬件触发|
|软中中断|swi|操作系统的系统调用|
|未定义指令|undefined||
|数据异常|abort|越界...|
|复位|Reset|软复位、硬复位、看门狗复位...|

## 6.2. 中断异常

- ARM有两级外部中断FIQ和IRQ；
- ARM需要通过中断控制器来处理多个中断；
- 中断标志用于记录中断来过，防止丢失中断(需要清标志)；
- 异常是随机的，所以需要异常向量表；
- 处理中断的过程由硬件完成(异常向量表)；
- 异常向量表：
  - Reset
  - Undefined Instruction
  - Software Interrupt
  - Prefetch Abort
  - Data Abort
  - IRQ
  - FIQ
- 异常与工作模式的对应关系
  |工作模式|异常|
  |:-:|:-|
  |USER|手动改CPSR实现切换|
  |FIQ|fiq|
  |IRQ|irq|
  |SVC|复位、软中断|
  |ABORT|Data/Prefetch Abort|
  |SYS|手动改CPSR实现切换|
  |UND|undefined instruction|

# 7. 无操作系统编程

## 7.1. 开发步骤

> MCU的开发可以使用RTOS，也可以不使用操作系统开发，不使用操作系统开发的步骤大致分为以下步骤：
>   - 看原理图，了解要控制模块的引脚关系图； 
>   - 看芯片手册
>     - 看要控制模块的芯片手册，了解如何控制；
>     - 看CPU的相关模块的控制方式
>     - 查看模块寄存器配置信息(有些厂商有提供库)
>   - 编程

## 7.2. 编译

- gcc (-E -S -c -I -L -l -D -o不同的编译选项)
- `ld led.o -Ttext 0x40002000 -o led.elf`：链接可执行文件(-Ttext 0x40002000用于指定链接地址)
- `ld led.o -Tmap.lds -o led.elf`链接脚本；
- `objcopy -O binary -S led.elf led.bin`：转文件格式；
- `objdump -D led.elf > led.dis`：反汇编

## 7.3. 链接脚本

```
/* 指定文件格式是elf32,小端存储 */
OUT_PUT_FORMAT("elf32-littlearm","elf32-littlearm")
/* 指定架构 */
OUTPUT_ARCH(arm)
/* 指定链接后可执行程序的第一条指令 */
ENTRY(_start)
/* 开始分配不同段地址 */
SECTIONS
{
  . = 0x40001000; /* 指定链接起始地址 */
  . = ALIGN(4);   /* 4字节对齐 */
  .text :         /* 指定接下来是代码段(只读段) */
  {
    start.o(.text)/* 指定start文件的代码段放到最开始的位置 */
    *(.text)      /* 其他文件的代码段 */
  }
  . = ALIGN(4);
  .data :         /* 指定数据段开始 */
  {*(.data)}      /* 所有数据段 */
  . = ALIGN(4);
  .bss  :         /* 未初始化变量 */
  {*(.bss)}
}
```

## 7.4. start.s

- 要实现异常向量表
- 要实现复位的中断处理函数
- 要给7种工作模式分配各自的栈；
- 指定栈大小
  ```
    .text
    stacktop:
      .word stack+1024@这里需要"+1024"吗？
    .data
    stack:
      .space 1024
  ```

## 7.5. 汇编和C语言混合编程

- `b main`：设置好栈之后通过该指令跳转到C；
- `.global func`：通过在汇编中使用".global"可以声明全局地址，被其他文件(包括C文件)调用；
- C语言中可以嵌套汇编：
  ```C
    uint add(uint a,uint b)
    {
      uint sum;
      //asm声明内联汇编，volatile防优化
      asm volatile
      {
        "add %1,%2\n\t"
        :"=r"(sum)  //输出操作符列表
        :"r"(a),"r"(b) //输入操作符列表
        :"memory"
      }
    }
  ```

# 8. 中断机制

|GPIO管脚控制|使能中断|分发|分发使能|接口|接口使能<br>优先级|nIRQ<br>nFIQ|ARM核|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|配置模式|ICDISER|ICDIPTR|ICDDCR|CPU0<br>CPU1<br>CPU2<br>CPU3|ICCICR||CORE0<br>CORE1<br>CORE2<br>CORE3|

## 8.1. 中断向量表基址修改

> &emsp;&emsp;默认情况下，异常向量表的基地址是0x0，在没有linux操作系统，借助u-boot裸跑一个程序时，程序被加载在什么地址，实际在运行时，异常向量表基址就需要改成该值。

- 借助协处理器(CP15)完成；
  ```ASM   

    @设置异常向量表基址：0x40001000
    ldr r0,=0x40001000
    mcr p15,0,r0,c12,c0,0
  ```
- 协处理器操作格式：
  ```ASM
    @MRC Pn,op1,Rd,CRn,CRm,op2
    @读入cp15的c1寄存器的内容到r0中    
    @mrc p15,0,r0,c1,c0,0

    @MCR Pn,op1,Rd,CRn,CRm,op2
    @写r0内容到cp15的c1寄存器中
    @mcr p15,0,r0,c1,c0,0
  ```

## 8.2. 中断处理过程

- 1. 中断初始化
  - 管脚初始化；
  - 中断控制器初始化；
- 2. 中断向量表
  - 中断发生后，硬件自动跳转到异常向量表的中断向量；
  - 调用中断向量处理函数
    - 保护现场；
    - 根据中断号调用C函数
- 3. 调用C函数
  - 做对应中断号的处理任务；
  - 清中断；
  - 恢复线程并返回；

- **注意**
  - 进入软中断，保护现场前，lr不变；
  - 进入中断，保护现场前，lr需要减4；
  - 使用"bl"跳转到C代码(`void do_irq(void)`)；
  - 通过寄存器"ICCIAR_CPU0/1/2/3"获取中断号(`m_usIrqNum = ICCIAR_CPU0&0x3FF`);

# 9. 协处理器

# N. 附录

## N.1. 备注

- keil种点击"Help->uVision Help"，会弹出帮助文档，其中有ARM指令的介绍；
- 汇编语言种的注释是一行语句前加"@"符号；
- 当操作数有三个(两个寄存器一个立即数)时，如果寄存器相同时可只写一个；
- C语言 -> 汇编 -> 机器码
  > CPU控制器取指->译码->存储到寄存器，然后由ALU运算器执行并返回结果到寄存器；
- `nop`：是指令，不执行，只占用空间和运行时间；
- "const"类型数据要定义在".text"段；
  
## N.2. 疑问

> - 普通模式下调用`msr cpsr,r0`改变模式，执行完没有改变模式，那会不会有标志来报指令执行失败的错误？
> - 机器码怎么通过手册来解析？
> - ".space"什么的数组元素的尺寸(1Byte?)
> - ".global"声明的全局符号有什么作用？怎么在别的文件调用全局符号？
> - 汇编程序中的标号什么作用，怎么使用？答：标号，相当于标号下一条指令的地址。
> - 汇编指令跳转到函数时怎么传参，最多传几个？ 
> - 汇编程序中有哪些段？
> - 使用"ldmia"等批量处理指令时，寄存器个数可以不是8的倍数码？寄存器可以不是连续排布的码？
> - "stmfd"和"ldmfd"操作多个寄存器入出栈时的寄存器顺序是？
> - "swi"指令中的软中断号可以取哪些值？这些值有什么使用场景？
> - 模式切换时，切换到其他模式之后，运行时是使用备份的寄存器，还是将原寄存器拷贝到备份寄存器中，继续使用原寄存器，CPSR应该是使用原寄存器，那R8 - R14呢？
> - "未定义指令"类型的异常有哪些使用场景？
> - 工作模式中的"SYS"有什么使用场景？
> - 软中断指令会保存跳转前下一条指令的地址到LR，那异常向量表中可以使用"bl"指令跳转吗？
> - 中断发生时需要保护现场，那函数调用需要吗？函数本身并不确定是几级调用，是不是意味着最好保存现场处理？
> - 保存线程时，保存哪些寄存器怎么确定？要保存现场的函数怎么知道之前哪些寄存器在使用？这是不是意味着最后把所有寄存器都保存一下？
> - "b"指令为什么能操作32M的空间，12位不是4K吗？
> - mov指令不能操作太大的立即数，那为什么bic、orr等可以？ARM指令除了mov指令,其他指令可以使用比较大的立即数吗？(`bic r0,#F0000000`)
> - 链接方式？链接脚本和直接链接怎么编写？
> - 汇编中怎么指定栈大小；
> - 不同的异常模式有哪些应用场景？
> - 多个CPU中中断怎么处理，某一个中断固定由某个核来处理吗？这样效率会不会变低？
> - 协处理器和CPU的关系？协处理器可以做哪些事？





